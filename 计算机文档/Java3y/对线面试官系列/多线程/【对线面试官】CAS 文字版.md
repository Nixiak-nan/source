三歪：淦，已经熬到了第6面了

三歪：上次问完多线程基础，我觉得我的表现还可以，听说这一次要深入一些

三歪：我猜就是会问synchronized锁吧，毕竟Thread类的API 没啥好问的，面试也一般不会问

三歪：嘿嘿，今天也肯定没问题

三歪：干就完事了



三歪：面试官你好，请问面试可以开始了吗？

面试官：嗯，开始了。

面试官：今天我们来聊聊CAS吧？你对CAS了解多少？

三歪：....

三歪：好

三歪：CAS的全称为compare and swap，比较并交换

三歪：虽然翻译过来是「比较并交换」，但它是一个原子性的操作，对应到CPU指令为cmpxchg

面试官：好家伙，CPU指令你都知道？

三歪：这没什么，都是背的。

面试官：....



三歪：回到CAS上吧，CAS的操作其实非常简单。

三歪：CAS 有三个操作数：当前值A、内存值V、要修改的新值B

三歪：假设 当前值A 跟 内存值V 相等，那就将 内存值V 改成B

三歪：假设 当前值A 跟 内存值V 不相等，要么就重试，要么就放弃更新

三歪：将当前值与内存值进行对比，判断是否有被修改过，这就是CAS的核心

面试官：确实，那为什么要用CAS呢？

三歪：嗯，要讲到CAS就不得不说synchronized锁了，它是Java锁...然后...

面试官：稍微打断一下，synchronized锁你稍微讲下就好了，后面会专门问的，在这不用细讲。

三歪：ok，其实就是synchronized锁每次只会让一个线程去操作共享资源

三歪：而CAS相当于没有加锁，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断能否修改成功

三歪：在很多的情况下会synchronized锁要高效很多

三歪：比如，对一个值进行累加，就没必要使用synchronized锁，使用juc包下的Atomic类就足以。

面试官：了解，那你知道CAS会有什么缺点吗？

三歪：CAS有个缺点就是会带来ABA的问题

三歪：从CAS更新的时候，我们可以发现它只比对当前值和内存值是否相等，这会带来个问题，下面我举例说明下：

三歪：假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10。

三歪：等到线程A拿到执行权时，因为当前值和内存值是一致的，线程A是可以修改的！

三歪：站在线程A的角度来说，这个值是从未被修改的（：

三歪：这是不合理的，因为我们从上帝的角度来看，这个变量已经被线程B和线程C修改过了。

三歪：这就是所谓的ABA问题

三歪：要解决ABA的问题，Java也提供了AtomicStampedReference类供我们用，说白了就是加了个版本，比对的就是内存值+版本是否一致

面试官：嗯，了解。

面试官：阿里巴巴开发手册提及到 推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）

面试官：你能帮我解读一下吗？

三歪：AtomicLong做累加的时候实际上就是多个线程操作同一个目标资源

三歪：在高并发时，只有一个线程是执行成功的，其他的线程都会失败，不断自旋（重试），自旋会成为瓶颈

三歪：而LongAdder的思想就是把要操作的目标资源「分散」到数组Cell中

三歪：每个线程对自己的 Cell 变量的 value 进行原子操作，大大降低了失败的次数

三歪：这就是为什么在高并发场景下，推荐使用LongAdder 的原因（：

面试官：OK

面试官：今天面试到这里就已经结束了，你有什么想问我的吗？

三歪：面试官您怎么不面synchronized锁啊？

面试官：别急，小伙子。synchronized下一次，下一次一定，synchronized可问的东西可比CAS多太多咯

三歪：哦



